---
title: TES Small Data Hackathon 2024
subtitle: Gromov–-Wasserstein-Based Shape, Graph and Image Analysis
author:
    - name: Florian Beier
      affiliation: "Technische Universität Berlin"
    - name: Robert Beinert
      affiliation: "Technische Universität Berlin"
    - name: Alonso Cisneros
      affiliation: "Zuse Institute Berlin"
    - name: Toluwa Okunola
      affiliation: "Technische Universität Berlin"
    - name: Maksym Dolgikh
      affiliation: "Freie Universität Berlin"
format:
    revealjs:
        theme: default
        html_math_method: mathjax
        incremental: true
execute: 
  echo: false
jupyter: python3
---

```{python}
import numpy as np
import matplotlib.pyplot as plt
from sklearn import manifold, cluster
import plotly.express as px
import ot
import trimesh
import open3d as o3d
import utils
from utils import GM
# from tqdm import trange

#plotting
import plotly.graph_objects as go
from plotly.subplots import make_subplots

from pathlib import Path
```


```{python}
models_path = Path.cwd()/'data/models'

def GM_short(mesh):
    return GM(X=mesh.vertices,
              Tris=mesh.faces,
              mode="surface",
              gauge_mode="djikstra",
              normalize_gauge=True,
              squared=False)
```


```{python}
sqd = 1000 #  parameter for mesh simplification

#LOAD ANIMALS dataset
animals = ['camel', 'cat', 'elephant', 'face', 'flamingo', 'head', 'horse', 'lion']
meshes_animals = []
names = []
for animal in animals:
    counter = 1
    pathlist = (models_path/f"{animal}-poses").rglob('*.obj')
    for path_to_obj in pathlist:
        filepath = str(path_to_obj)
        pcd = o3d.io.read_triangle_mesh(filepath)
        mesh = trimesh.Trimesh(vertices=pcd.vertices,faces = pcd.triangles)

        #simplifiy mesh
        mesh = mesh.simplify_quadric_decimation(sqd)

        #append mesh to list
        meshes_animals.append(mesh)
        names.append(animal + str(counter).zfill(2))
        counter += 1
```


```{python}
#choose gm-spaces
i, j = 0, 1

X = GM_short(meshes_animals[i])
Y = GM_short(meshes_animals[j])

#compute GW Plan
P,log = ot.gromov.gromov_wasserstein(X.g,Y.g,X.xi,Y.xi,log=True)
print("GW Transport costs: {0}".format(log["gw_dist"]))
```


# Intro

## Theory

## Wasserstein Distance

- Let $X = Y = \mathbb{R}^d$, $\mu \in \mathcal{P}_2(X)$, $\nu \in
\mathcal{P}_2(Y)$.
- Let $\Pi(\mu, \nu) \subset \mathcal{P}(X \times Y)$ denote the set of all
_transport plans_ $\pi$ with marginal $\mu$, $\nu$, i.e.
$$
\begin{align*}
(P_X)_\# \pi (A) &:= \pi(P_X^{-1} A) = \pi(A \times Y) = \mu(A) \\
(P_Y)_\# \pi(B) &= \nu(B)
\end{align*}
$$
for all measurable $A \subset X$, $B \subset Y$.

## 

- Extremely computationally expensive

- Sensitive to orientation

## Gromov-Wasserstein Distance

The **Gromov--Wasserstein distance** between $\mathbb{X} = (X,d_X,\mu)$ and
$\mathbb{Y} = (Y,d_Y,\nu)$ is given by:

::: {.smaller}
$$
\operatorname{GW}(\mathbb{X},\mathbb{Y}) := \displaystyle \inf_{\pi \in \Pi(\mu,\nu)} \biggl(\int_{(X \times Y)^2} \bigl(d_X(x,x') - d_Y(y,y')\bigr)^2 \mathrm{d}x \, \pi(x,y) \mathrm{d}x \, \pi(x',y') \biggr)^\frac{1}{2}.
$$

:::

- Dependent only on the geometry of the object
    - e.g. orientation invariant, pose invariant (somewhat)

- Even more computationally expensive.

# The problem

- Classification/Clustering of shapes via their pairwise Gromov--Wasserstein
distance.

- 

## The dataset

show some models of 2d & 3d

## Some transport plans

```{python}
width = 500
height = 500
ambient = 0.4

#colour-code X
cX = np.linalg.norm(X.X - np.min(X.X),axis=1)
#colour-code Y according to transport P
cY = (P.T / np.sum(P,axis=1)).dot(cX)

#plot
fig = make_subplots(rows=1, cols=2,
               specs=[[{'type': 'scene'}] * 2],shared_xaxes=True)
#plot X
fig.add_trace(
    go.Mesh3d(
    x=X.X[:,0], y=X.X[:,1], z=X.X[:,2],
    # Intensity of each vertex, which will be interpolated and color-coded
    intensity=cX,
    # i, j and k give the vertices of triangles
    i=X.Tris[:,0], j=X.Tris[:,1], k=X.Tris[:,2],
    showscale=False,
    lighting=dict(ambient=ambient)
),
    row = 1, col = 1
)

#plot Y
fig.add_trace(
    go.Mesh3d(
    x=Y.X[:,0], y=Y.X[:,1], z=Y.X[:,2],
    # Intensity of each vertex, which will be interpolated and color-coded
    intensity=cY,
    # i, j and k give the vertices of triangles
    i=Y.Tris[:,0], j=Y.Tris[:,1], k=Y.Tris[:,2],
    showscale=False,
    lighting=dict(ambient=ambient)
),
    row = 1, col = 2
)

fig.update_scenes(aspectmode='data')
fig.update_layout(showlegend=False,width=width,height=height)

fig = go.FigureWidget(fig)
fig.show()
```

## Drawbacks of full Gromov-Wasserstein

- Very accurate but extremely computationally expensive

- Takes around 1 hr 5 min to compute pairwise G-W distance between figures with 500
nodes.


## Taming computational complexity

- Linearized Gromov--Wasserstein (LGV)
    - Less accurate but much easier to compute

- The same pairwise distance calculation took 13 min (vs more than 1 hr)
    - 5x reduction in time

# Results


```{python}
m_bodies = np.load("aggregated_distances_lgw_sqd500.npy")
names = np.load("image_names.npy")
animals = ['camel', 'cat', 'elephant', 'face', 'flamingo', 'head', 'horse', 'lion']
avg = np.min(m_bodies, axis=0)
mds = manifold.MDS(
    n_components=3,
    max_iter=3000,
    eps=1e-9,
    dissimilarity="precomputed",
    n_jobs=1,
)
pos = mds.fit(avg).embedding_
kmeans = cluster.KMeans(n_clusters=8, random_state=0, n_init="auto").fit(pos)
# plt.scatter(pos[:, 0], pos[:, 1], c = kmeans.labels_)
px.scatter_3d(x=pos[:, 0], y=pos[:, 1], z=pos[:, 2], color = kmeans.labels_)
```

## Classification results

::: {.panel-tabset}

### G--W
![](figs/gw.png)

### Agg. Linearized G--W {.smaller}
![](figs/algw.png)

### Linearized G--W {.smaller}
![](figs/lgw.png)

:::

# Possible future work

- One random animal as reference per class. We could possibly choose a "model"
reference animal per class.

- Inference can be implemented by calculating "barycenters" of classes and
computing distance to them. The inferred class would be the one whose barycenter
is the closest.
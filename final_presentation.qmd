---
title: TES Small Data Hackathon 2024
subtitle: Gromov–-Wasserstein-Based Shape, Graph and Image Analysis
author:
    - name: Florian Beier
      affiliation: "Technische Universität Berlin"
    - name: Robert Beinert
      affiliation: "Technische Universität Berlin"
    - name: Alonso Cisneros
      affiliation: "Zuse Institute Berlin"
    - name: Toluwa Okunola
      affiliation: "Technische Universität Berlin"
    - name: Maksym Dolgikh
      affiliation: "Freie Universität Berlin"
format:
    revealjs:
        theme: default
        html_math_method: mathjax
        incremental: true
        logo: figs/MATHPLUS-Logo-retina.png
execute: 
  echo: false
jupyter: python3
---

```{python}
import numpy as np
import matplotlib.pyplot as plt
from sklearn import manifold, cluster
import plotly.express as px
import ot
import trimesh
import open3d as o3d
import utils
from utils import GM

#plotting
import plotly.graph_objects as go
from plotly.subplots import make_subplots

from pathlib import Path
```


```{python}
models_path = Path.cwd()/'data/models'

def GM_short(mesh):
    return GM(X=mesh.vertices,
              Tris=mesh.faces,
              mode="surface",
              gauge_mode="djikstra",
              normalize_gauge=True,
              squared=False)
```


```{python}
sqd = 1000 #parameter for mesh simplification

#LOAD ANIMALS dataset
meshes_animals = []
pathlist_all = list((models_path/f"lion-poses").rglob('*.obj'))
pathlist = (pathlist_all[1], pathlist_all[8])
for path_to_obj in pathlist:
    filepath = str(path_to_obj)
    pcd = o3d.io.read_triangle_mesh(filepath)
    mesh = trimesh.Trimesh(vertices=pcd.vertices,faces = pcd.triangles)

    #simplifiy mesh
    mesh = mesh.simplify_quadric_decimation(sqd)

    #append mesh to list
    meshes_animals.append(mesh)
```


```{python}

#choose gm-spaces
X = GM_short(meshes_animals[0])
Y = GM_short(meshes_animals[1])

#compute GW Plan
P,log = ot.gromov.gromov_wasserstein(X.g,Y.g,X.xi,Y.xi,log=True)
```


# Intro

- The Gromov-Wasserstein (GW) distance is an optimal transport-based metric,
  - allows for embedding-free comparisons and
  - matchings of gauged measure spaces (like 3d shapes)

- We use several generalizations of (GW) to solve the task of classifying 3d
Euclidean shapes.

## Wasserstein Distance

- Let $X = Y = \mathbb{R}^d$, $\mu \in \mathcal{P}_2(X)$, $\nu \in
\mathcal{P}_2(Y)$.

- Let $\Pi(\mu, \nu) \subset \mathcal{P}(X \times Y)$ denote the set of all
_transport plans_ $\pi$ with marginal $\mu$, $\nu$

- The _Wasserstein distance_ is defined as
$$
W(\mu,\nu) \coloneqq \inf_{\pi \in \Pi(\mu,\nu)} \biggl(\int_{X \times Y} \|x-y\|_2^2 \dx \pi(x,y) \biggr)^{\frac{1}{2}}.
$$

- Sensitive to orientation

- Computationally expensive

## Gromov-Wasserstein Distance

The **Gromov--Wasserstein distance** between $\mathbb{X} = (X,d_X,\mu)$ and
$\mathbb{Y} = (Y,d_Y,\nu)$ is given by:

:::{style="font-size:75%;"}
$$
\operatorname{GW}(\mathbb{X},\mathbb{Y}) := \inf_{\pi \in \Pi(\mu,\nu)} \biggl(\int_{(X \times Y)^2} \bigl(d_X(x,x') - d_Y(y,y')\bigr)^2 \mathrm{d}x \, \pi(x,y) \mathrm{d}x \, \pi(x',y') \biggr)^\frac{1}{2}.
$$

:::

- Dependent only on the geometry of the object
    - e.g. orientation invariant, pose invariant (somewhat)

- Even more computationally expensive.

# The problem

- Classification/Clustering of shapes via their pairwise Gromov--Wasserstein
distance.

## The dataset

```{python}

width = 500
height = 500
ambient = 0.4

#colour-code X
cX = np.linalg.norm(X.X - np.min(X.X),axis=1)
#colour-code Y according to transport P
cY = (P.T / np.sum(P,axis=1)).dot(cX)

#plot
fig = make_subplots(rows=1, cols=2,
               specs=[[{'type': 'scene'}] * 2],shared_xaxes=True)
#plot X
fig.add_trace(
    go.Mesh3d(
    y=X.X[:,0], z=X.X[:,1], x=X.X[:,2],
    # Intensity of each vertex, which will be interpolated and color-coded
    intensity=cX,
    # i, j and k give the vertices of triangles
    k=X.Tris[:,0], i=X.Tris[:,1], j=X.Tris[:,2],
    showscale=False,
    lighting=dict(ambient=ambient)
),
    row = 1, col = 1
)

#plot Y
fig.add_trace(
    go.Mesh3d(
    y=Y.X[:,0], z=Y.X[:,1], x=Y.X[:,2],
    # Intensity of each vertex, which will be interpolated and color-coded
    intensity=cY,
    # i, j and k give the vertices of triangles
    k=Y.Tris[:,0], i=Y.Tris[:,1], j=Y.Tris[:,2],
    showscale=False,
    lighting=dict(ambient=ambient)
),
    row = 1, col = 2
)

fig.update_scenes(aspectmode='data')
fig.update_layout(showlegend=False)  #  ,width=width,height=height)

fig = go.FigureWidget(fig)
fig.show()
```

##

![Some other example shapes from Mesh Data from
Deformation Transfer for Triangle Meshes (Summer, Popovic)](figs/animal_collection.png)

## Drawbacks of full Gromov-Wasserstein

- Very accurate but extremely computationally expensive

- Takes around 1 hr 5 min to compute pairwise G-W distance between 83 figures with 500
nodes.


## Taming computational complexity

- Linearized Gromov--Wasserstein (LGW)
    - Less accurate but much easier to compute

- The same pairwise distance calculation took 13 min (vs more than 1 hr)
    - 5x reduction in time

# Results

- Computing GW distances and then using Multidimensional Scaling (MDS) to embedd into 3d space.

. . .

```{python}
m_bodies = np.load("aggregated_distances_lgw_sqd500.npy")
names = np.load("image_names.npy")
animals = ['camel', 'cat', 'elephant', 'face', 'flamingo', 'head', 'horse', 'lion']
animals_nd = np.asanyarray(animals)
avg = np.min(m_bodies, axis=0)
mds = manifold.MDS(
    n_components=3,
    max_iter=3000,
    eps=1e-9,
    dissimilarity="precomputed",
    n_jobs=1,
)
pos = mds.fit(avg).embedding_
kmeans = cluster.KMeans(n_clusters=8, random_state=0, n_init="auto").fit(pos)
# plt.scatter(pos[:, 0], pos[:, 1], c = kmeans.labels_)
px.scatter_3d(x=pos[:, 0], y=pos[:, 1], z=pos[:, 2], color = kmeans.labels_, hover_name=animals_nd[kmeans.labels_])
```

## Classification results

::: {.panel-tabset}

### G--W
![](figs/gw.png)

### Agg. Linearized G--W {.smaller}
![](figs/algw.png)

### Linearized G--W {.smaller}
![](figs/lgw.png)

:::

## Drawbacks of full Gromov-Wasserstein

- Very accurate but extremely computationally expensive

- Takes around 1 hr 5 min to compute pairwise G-W distance between 83 figures with 500
nodes.


## Taming computational complexity

- Linearized Gromov--Wasserstein (LGW)
    - Less accurate but much easier to compute

- The same pairwise distance calculation took 13 min (vs more than 1 hr)
    - 5x reduction in time

# Possible future work

- One random animal as reference per class. We could possibly choose a "model"
reference animal per class. Or reduce the number of references.

- Try bigger datasets.

- Inference can be implemented by calculating "barycenters" of classes and
computing distance to them. The inferred class would be the one whose barycenter
is the closest.